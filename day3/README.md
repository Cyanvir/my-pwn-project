# 🛡️ Pwn 学习日志：通配符、管道与重定向详解

**日期：** 2026-02-07
**学习平台：** pwn.college
**完成模块：**
- [x] Linux Luminarium: File Globbing
- [x] Linux Luminarium: Piping and Redirection

---

## 1. 🌟 文件通配符 (File Globbing)

当文件名太长、太复杂，或者你想一次性操作多个文件时，Globbing 是你的好帮手。

| 符号 | 名称 | 含义与用法 | 示例 | 匹配结果 |
| :--- | :--- | :--- | :--- | :--- |
| `*` | 星号 | **匹配任意长度的任意字符**（包括空字符）。 | `rm pwn*` | 删除所有以 `pwn` 开头的文件（如 `pwn`, `pwn1`, `pwn_college`）。 |
| `?` | 问号 | **匹配任意单个字符**。 | `ls flag?` | 匹配 `flag1`, `flagA`，但不匹配 `flag12`。 |
| `[]` | 方括号 | **匹配括号内的任意一个字符**。 | `ls file[ab]` | 只匹配 `filea` 或 `fileb`。 |
| `[-]` | 范围 | **匹配指定范围内的字符**。 | `ls file[0-9]` | 匹配 `file0` 到 `file9` 的所有文件。 |
| `[!]` 或 `[^]` | 取反 | **匹配除了括号内字符以外的字符**。 | `ls file[!a]` | 匹配 `fileb`, `file1`，但不匹配 `filea`。 |

> **💡 提示：** 通配符是由 **Shell** 解析的，而不是由命令（如 `ls`）解析的。Shell 会先把 `*` 变成具体的文件名列表，然后再传给命令。

---

## 2. 🚀 输入输出重定向 (I/O Redirection)

Linux 中的每个进程都有三个默认的数据流（File Descriptors, FD）：
* **STDIN (0):** 标准输入（通常是键盘）
* **STDOUT (1):** 标准输出（通常是屏幕）
* **STDERR (2):** 标准错误（通常也是屏幕，用于显示报错）

### 2.1 基础重定向
* `>` (覆盖输出): 将 STDOUT 输出到文件。如果文件存在，**覆盖**它。
    * `echo "hello" > file.txt`
* `>>` (追加输出): 将 STDOUT 输出到文件。如果文件存在，**追加**到末尾。
* `<` (输入重定向): 让命令从文件读取内容，而不是从键盘。
    * `cat < flag` (等同于 `cat flag`)

### 2.2 错误流重定向 (FD 2)
* **`2>`**: 只重定向错误信息。
    * `./run 2> errors.log` (正常输出显示在屏幕，报错写入文件)
* **`2>&1`**: **这是最关键的组合拳**。
    * **含义：** 把 FD 2 (错误) 的输出导向 FD 1 (标准输出) 去的地方。
    * **用法：** `./run > output.txt 2>&1`
    * **解释：** “先把标准输出存到 output.txt，然后把错误信息也扔进同一个通道。” 这样你的文件里既有正常结果，也有报错信息。

### 2.3 管道 `|` (Pipe)
* **含义：** 把 **左边命令的 STDOUT** 直接接到 **右边命令的 STDIN**。
* **形象理解：** 像是接水管，左边流出的水直接流进右边的管子里，不经过地面（文件）。
* **示例：** `cat flag | grep "pwn"` (读取 flag 内容，通过管道传给 grep 进行筛选)。

---

## 3. 🛠️ 数据处理三剑客：Grep, Sed, Tee

在管道中，我们经常需要对数据进行修剪。

### 3.1 grep -v (反向筛选)
* `grep "text"`: 只保留包含 "text" 的行。
* **`grep -v "text"`**: **删除/排除**包含 "text" 的行，保留其他所有行。
    * *场景：* 题目输出了一万行垃圾日志，只有一行是 Flag，你可以用 `grep -v "info"` 过滤掉垃圾日志。

### 3.2 sed (流编辑器)
* 最常用功能是**替换**。
* **语法：** `s/旧内容/新内容/g`
* **示例：** `cat flag | sed 's/pwn/PWN/g'`
    * 把 flag 里的所有小写 `pwn` 替换成大写 `PWN`。

### 3.3 tee (三通管道) —— ⭐ 重点掌握
* **为什么叫 tee？** 就像水管工用的 **T型接头**。
* **功能：** 它读取 STDIN，然后**同时**做两件事：
    1.  把数据写入一个文件。
    2.  把数据原样输出到 STDOUT (传给下一个命令)。
* **图解：**
    ```
          输入
           ⬇
        -------
        | tee | ➡ 输出到文件 (file.txt)
        -------
           ⬇
      输出到屏幕 (或下一个管道)
    ```
* **使用场景：** 当你既想把中间结果保存下来分析，又想让程序继续运行。
    * `cat flag | tee copy_of_flag.txt | grep "pwn"`

---

## 4. 🧠 进阶难点总结 (今天遇到的坑)

### 4.1 命名管道 (Named Pipes / FIFOs)
* **命令：** `mkfifo mypipe`
* **特性：** 它是一个文件，但它是**阻塞**的。
* **阻塞问题解析：**
    * FIFO 必须**两头通**才能流动。
    * 如果你只在一个终端运行 `cat mypipe` (读)，它会**卡住**，直到有人往里写数据。
    * 如果你只在一个终端运行 `echo "hi" > mypipe` (写)，它也会**卡住**，直到有人来读数据。
* **解决方案 (双终端法)：**
    1.  **终端 A (读):** `cat mypipe` (此时会挂起等待)
    2.  **终端 B (写):** `echo "SECRET" > mypipe`
    3.  此时终端 A 会瞬间收到 "SECRET" 并结束挂起。

### 4.2 进程替换 (Process Substitution) `>()`
这是一个非常高级的技巧，用来解决“某些命令只接受**文件路径**作为参数，不接受 stdin 管道”的情况。
只需要记住它的核心作用：**欺骗**。
它欺骗那个必须读取文件的命令，给它一个“假文件”，实际上连接的是另一个程序。

* **语法：** `>()`
* **原理：** Linux 会创建一个临时的文件描述符（看起来像个文件路径 `/dev/fd/63`），命令往这个“假文件”里写数据时，实际上是写给了括号里的命令。
* **典型场景：** `tee` 命令配合 `>()`。
    * `./run | tee >(grep "flag" > flag_found.txt)`
    * *解释：* 程序运行，tee 把输出分流，一路正常显示，另一路通过 `>()` 伪装成文件，喂给了 grep 进行处理。
* **❌ 常见误区 (踩过的坑)：**
    * **空格问题：** `> >(cmd)` 是对的。`>> (cmd)` 可能会报错。
    * **把它当管道：** 它不是管道。它是**把一个正在运行的命令伪装成一个文件路径**。
    * **命令：** `diff <(cmd1) <(cmd2)` 是比较两个命令输出的最快方法，不需要生成中间文件。